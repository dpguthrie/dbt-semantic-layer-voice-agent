<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantic Layer Assistant</title>
    <!-- Add marked library for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Add highlight.js with SQL support -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>
    <!-- Add Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@4.1.0/cdn.min.js" integrity="sha256-bDgRIzo3i6VHqJMlDwUcu/g1mnxCoS6B1sNW3269kJY=" crossorigin="anonymous"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            background-color: #f0f0f0;
            display: flex;
        }

        /* Left sidebar styling */
        .sidebar {
            width: 280px;
            background-color: #0f172a;
            color: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #1e293b;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #1e293b;
        }

        .new-chat-btn {
            width: 100%;
            padding: 10px;
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: background-color 0.3s;
        }

        .new-chat-btn:hover {
            background-color: #2563eb;
        }

        .saved-chats {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .chat-item {
            padding: 10px;
            margin: 5px 0;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #94a3b8;
            transition: background-color 0.3s;
            position: relative;
        }

        .chat-item:hover {
            background-color: #1e293b;
            color: white;
        }

        .chat-item.active {
            background-color: #1e293b;
            color: white;
        }

        /* Main content styling */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            width: 100%;
            position: relative;
            background: white;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 80px; /* Add padding to prevent messages from being hidden behind controls */
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .message {
            max-width: 85%;  /* Increased from 70% */
            padding: 10px 15px;
            border-radius: 15px;
            margin: 5px 0;
        }

        .message pre {
            position: relative;
            background-color: #f8f9fa;
            padding: 1em 0.5em 1em 3.8em !important;
            border-radius: 5px;
            overflow-x: auto;
            margin: 5px 0;
            counter-reset: line;
            line-height: 1.5;
        }

        .message pre code {
            font-family: 'Courier New', Courier, monospace;
            display: block;
        }

        .message pre code .line {
            display: block;
            position: relative;
        }

        .message pre code .line:before {
            counter-increment: line;
            content: counter(line);
            position: absolute;
            left: -3.3em;
            width: 2.5em;
            text-align: right;
            color: #999;
            padding-right: 0.5em;
            border-right: 1px solid #ddd;
            user-select: none;
        }

        .message code {
            font-family: 'Courier New', Courier, monospace;
        }

        .user-message {
            background-color: #007bff;
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 5px;
        }

        .assistant-message {
            background-color: #e9ecef;
            color: black;
            align-self: flex-start;
            border-bottom-left-radius: 5px;
        }

        /* Tabs styling */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .tab {
            padding: 8px 16px;
            background-color: #f8f9fa;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .tab.active {
            background-color: #007bff;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Table styling */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }

        .data-table th, .data-table td {
            border: 1px solid #dee2e6;
            padding: 8px;
            text-align: left;
        }

        .data-table th {
            background-color: #f8f9fa;
            font-weight: bold;
        }

        .data-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        .controls {
            padding: 20px;
            background: white;
            border-top: 1px solid #dee2e6;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            position: sticky;
            bottom: 0;
            z-index: 100;
        }

        #toggleAudio, #clearChat {
            font-size: 16px;
            padding: 12px 24px;
            cursor: pointer;
            border: none;
            border-radius: 25px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #clearChat {
            background-color: #6c757d;
            color: white;
        }

        #clearChat:hover {
            background-color: #5a6268;
        }

        #toggleAudio {
            background-color: #dc3545;
            color: white;
        }

        #toggleAudio.recording {
            background-color: #dc3545;
            animation: pulse 1.5s infinite;
        }

        #toggleAudio:not(.recording) {
            background-color: #0d6efd;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }

        .loading {
            display: none;
            align-items: center;
            gap: 8px;
            color: #6c757d;
        }

        .loading.active {
            display: flex;
        }

        .loading-dots {
            display: flex;
            gap: 4px;
        }

        .dot {
            width: 8px;
            height: 8px;
            background-color: #6c757d;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out;
        }

        .dot:nth-child(1) { animation-delay: -0.32s; }
        .dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        /* Copy button styling */
        .copy-button {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 5px 10px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .copy-button:hover {
            opacity: 1;
        }

        .copy-button.copied {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        /* Chart container styling */
        .chart-container {
            width: 100%;
            min-width: 600px;  /* Add minimum width */
            height: 400px;
            position: relative;
            margin-top: 10px;
            overflow-x: auto;  /* Allow horizontal scrolling if needed */
            padding: 20px;     /* Add padding around the chart */
        }

        /* Make sure the canvas respects the container size */
        .chart-container canvas {
            width: 100% !important;
            height: 100% !important;
            min-width: 600px;  /* Match container min-width */
        }

        /* Ensure tab content maintains width */
        .tab-content.active {
            display: block;
            width: 100%;
            min-width: 600px;  /* Match container min-width */
            overflow-x: auto;  /* Allow horizontal scrolling if needed */
        }

        /* Add styles for conversation title editing */
        .chat-item .actions {
            display: none;
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            gap: 5px;
        }

        .chat-item:hover .actions {
            display: flex;
        }

        .action-btn {
            padding: 4px;
            background: none;
            border: none;
            color: #94a3b8;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .action-btn:hover {
            opacity: 1;
        }

        .edit-title-input {
            width: 100%;
            padding: 8px;
            background: #1e293b;
            border: 1px solid #3b82f6;
            border-radius: 4px;
            color: white;
            font-size: 14px;
        }

        .edit-title-input:focus {
            outline: none;
            border-color: #60a5fa;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="sidebar-header">
            <button class="new-chat-btn" id="newChatBtn">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                New Chat
            </button>
        </div>
        <div class="saved-chats" id="savedChats">
            <!-- Saved chats will be dynamically added here -->
        </div>
    </div>
    <div class="main-content">
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages">
                <div class="message assistant-message">
                    Hello! I'm your dbt Semantic Layer assistant. Click "Start Recording" below and ask some questions!
                </div>
            </div>
            <div class="controls">
                <button id="toggleAudio">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                        <line x1="12" y1="19" x2="12" y2="23"/>
                        <line x1="8" y1="23" x2="16" y2="23"/>
                    </svg>
                    Start Recording
                </button>
                <button id="clearChat">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3-1V3a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1v2"/>
                        <line x1="10" y1="11" x2="10" y2="17"/>
                        <line x1="14" y1="11" x2="14" y2="17"/>
                    </svg>
                    Clear Chat
                </button>
                <div class="loading" id="loadingIndicator">
                    Processing
                    <div class="loading-dots">
                        <div class="dot"></div>
                        <div class="dot"></div>
                        <div class="dot"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Create audio context
        const BUFFER_SIZE = 4800;
        
        // Add conversation management functionality
        let conversations = [];
        let currentConversationId = null;
        let ws = null;

        async function fetchConversations() {
            const response = await fetch('/api/conversations');
            conversations = await response.json();
            renderConversations();
        }

        async function createNewConversation() {
            const response = await fetch('/api/conversations', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title: 'New Conversation' })
            });
            const conversation = await response.json();
            conversations.unshift(conversation);
            currentConversationId = conversation.id;
            renderConversations();
            clearChat();
            connectWebSocket();
        }

        async function loadConversation(id) {
            const response = await fetch(`/api/conversations/${id}`);
            const conversation = await response.json();
            currentConversationId = conversation.id;
            clearChat();
            
            // Disconnect existing WebSocket if any
            if (ws) {
                ws.close();
            }

            // Render all messages
            conversation.messages.forEach(msg => {
                if (msg.data) {
                    // It's a query result with chart/table
                    addMessage(msg.text, msg.is_user, msg.data);
                } else {
                    addMessage(msg.text, msg.is_user);
                }
            });

            renderConversations();
            connectWebSocket();
        }

        async function updateConversationTitle(id, title) {
            await fetch(`/api/conversations/${id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ title })
            });
            const conversation = conversations.find(c => c.id === id);
            if (conversation) {
                conversation.title = title;
                renderConversations();
            }
        }

        async function deleteConversation(id) {
            if (!confirm('Are you sure you want to delete this conversation?')) {
                return;
            }
            
            await fetch(`/api/conversations/${id}`, { method: 'DELETE' });
            conversations = conversations.filter(c => c.id !== id);
            
            if (currentConversationId === id) {
                currentConversationId = null;
                clearChat();
                if (conversations.length > 0) {
                    await loadConversation(conversations[0].id);
                }
            }
            
            renderConversations();
        }

        function renderConversations() {
            const container = document.getElementById('savedChats');
            container.innerHTML = '';
            conversations.forEach(conv => {
                const chatItem = document.createElement('div');
                chatItem.className = `chat-item ${conv.id === currentConversationId ? 'active' : ''}`;
                chatItem.innerHTML = `
                    <div class="chat-content">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        <span class="title">${conv.title}</span>
                    </div>
                    <div class="actions">
                        <button class="action-btn edit-btn" title="Edit title">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                                <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                            </svg>
                        </button>
                        <button class="action-btn delete-btn" title="Delete conversation">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M3 6h18"></path>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>
                    </div>
                `;

                // Add click handlers
                chatItem.querySelector('.chat-content').onclick = () => loadConversation(conv.id);
                
                const editBtn = chatItem.querySelector('.edit-btn');
                editBtn.onclick = (e) => {
                    e.stopPropagation();
                    const titleSpan = chatItem.querySelector('.title');
                    const currentTitle = titleSpan.textContent;
                    
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'edit-title-input';
                    input.value = currentTitle;
                    
                    input.onkeydown = async (e) => {
                        if (e.key === 'Enter') {
                            const newTitle = input.value.trim();
                            if (newTitle && newTitle !== currentTitle) {
                                await updateConversationTitle(conv.id, newTitle);
                            }
                            titleSpan.textContent = newTitle || currentTitle;
                            input.replaceWith(titleSpan);
                        } else if (e.key === 'Escape') {
                            input.replaceWith(titleSpan);
                        }
                    };
                    
                    input.onblur = () => {
                        input.replaceWith(titleSpan);
                    };
                    
                    titleSpan.replaceWith(input);
                    input.focus();
                    input.select();
                };
                
                chatItem.querySelector('.delete-btn').onclick = (e) => {
                    e.stopPropagation();
                    deleteConversation(conv.id);
                };

                container.appendChild(chatItem);
            });
        }

        function connectWebSocket() {
            if (ws) {
                ws.close();
            }

            const wsUrl = new URL('/ws', window.location.href);
            wsUrl.protocol = wsUrl.protocol.replace('http', 'ws');
            if (currentConversationId) {
                wsUrl.searchParams.set('conversation_id', currentConversationId);
            }
            
            ws = new WebSocket(wsUrl.toString());
            
            // ... rest of WebSocket setup code ...
        }

        // Initialize conversation management
        document.getElementById('newChatBtn').onclick = createNewConversation;
        fetchConversations();

        // Modify clearChat to handle conversation state
        function clearChat() {
            const messagesContainer = document.getElementById('chatMessages');
            // Keep only the first welcome message
            const welcomeMessage = messagesContainer.firstElementChild;
            messagesContainer.innerHTML = '';
            messagesContainer.appendChild(welcomeMessage);
        }

        // Player and Recorder classes remain the same
        class Player {
            constructor() {
                this.playbackNode = null;
            }

            async init(sampleRate) {
                const audioContext = new AudioContext({ sampleRate });
                await audioContext.audioWorklet.addModule("/audio-playback-worklet.js");

                this.playbackNode = new AudioWorkletNode(audioContext, "audio-playback-worklet");
                this.playbackNode.connect(audioContext.destination);
            }

            play(buffer) {
                if (this.playbackNode) {
                    this.playbackNode.port.postMessage(buffer);
                }
            }

            stop() {
                if (this.playbackNode) {
                    this.playbackNode.port.postMessage(null);
                }
            }
        }   

        class Recorder {
            constructor(onDataAvailable) {
                this.onDataAvailable = onDataAvailable;
                this.audioContext = null;
                this.mediaStream = null;
                this.mediaStreamSource = null;
                this.workletNode = null;
            }

            async start(stream) {
                console.log('starting')
                try {
                    if (this.audioContext) {
                        await this.audioContext.close();
                    }

                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
                    await this.audioContext.audioWorklet.addModule("/audio-processor-worklet.js");

                    this.mediaStream = stream;
                    this.mediaStreamSource = this.audioContext.createMediaStreamSource(this.mediaStream);

                    this.workletNode = new AudioWorkletNode(this.audioContext, "audio-processor-worklet");
                    this.workletNode.port.onmessage = event => {
                        this.onDataAvailable(event.data.buffer);
                    };

                    this.mediaStreamSource.connect(this.workletNode);
                    console.log('recorder setup complete');
                } catch (error) {
                    console.error('Error setting up recorder:', error);
                    this.stop();
                    throw error;
                }
            }

            async stop() {
                if (this.workletNode) {
                    this.workletNode.port.onmessage = null;
                    this.workletNode.disconnect();
                    this.workletNode = null;
                }

                if (this.mediaStreamSource) {
                    this.mediaStreamSource.disconnect();
                    this.mediaStreamSource = null;
                }

                if (this.mediaStream) {
                    this.mediaStream.getTracks().forEach(track => track.stop());
                    this.mediaStream = null;
                }

                if (this.audioContext) {
                    await this.audioContext.close();
                    this.audioContext = null;
                }
            }
        }

        // Function to add a message to the chat
        function addMessage(text, isUser = false, data = null) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user-message' : 'assistant-message'}`;
            
            try {
                // Try to parse as JSON in case it's a query result
                const dataObj = JSON.parse(text);
                if (dataObj.sql && dataObj.data) {
                    // Create tabs container
                    const tabsContainer = document.createElement('div');
                    tabsContainer.className = 'tabs';
                    
                    // Create Chart tab
                    const chartTab = document.createElement('button');
                    chartTab.className = 'tab active';
                    chartTab.textContent = 'Chart';

                    // Create Data tab
                    const dataTab = document.createElement('button');
                    dataTab.className = 'tab';
                    dataTab.textContent = 'Data';
                    
                    // Create SQL tab
                    const sqlTab = document.createElement('button');
                    sqlTab.className = 'tab';
                    sqlTab.textContent = 'SQL';
                    
                    // Add tabs in new order
                    tabsContainer.appendChild(chartTab);
                    tabsContainer.appendChild(dataTab);
                    tabsContainer.appendChild(sqlTab);
                    
                    // Create content containers
                    const chartContent = document.createElement('div');
                    chartContent.className = 'tab-content active';
                    
                    // Create chart container
                    const chartContainer = document.createElement('div');
                    chartContainer.className = 'chart-container';
                    const canvas = document.createElement('canvas');
                    chartContainer.appendChild(canvas);
                    chartContent.appendChild(chartContainer);

                    // Initialize chart if config exists
                    if (dataObj.chart_config) {
                        const ctx = canvas.getContext('2d');
                        // Create chart with simplified time axis configuration
                        const config = {
                            ...dataObj.chart_config,
                            options: {
                                ...dataObj.chart_config.options,
                                maintainAspectRatio: false,
                                responsive: true,
                                scales: {
                                    ...dataObj.chart_config.options.scales,
                                    x: {
                                        type: 'category',  // Use category instead of time
                                        display: true,
                                        title: {
                                            display: true
                                        }
                                    }
                                },
                                layout: {
                                    padding: {
                                        top: 20,
                                        right: 20,
                                        bottom: 20,
                                        left: 20
                                    }
                                }
                            }
                        };
                        new Chart(ctx, config);
                    } else {
                        chartContent.innerHTML = '<p>No chart configuration available for this data.</p>';
                    }

                    const dataContent = document.createElement('div');
                    dataContent.className = 'tab-content';
                    
                    const sqlContent = document.createElement('div');
                    sqlContent.className = 'tab-content';
                    
                    // Create pre and code elements with line numbers
                    const pre = document.createElement('pre');
                    const code = document.createElement('code');
                    code.className = 'sql';
                    
                    // Split SQL into lines and wrap each in a span
                    const lines = dataObj.sql.split('\n');
                    code.innerHTML = lines.map(line => 
                        `<span class="line">${line}</span>`
                    ).join('\n');
                    
                    // Add copy button
                    const copyButton = document.createElement('button');
                    copyButton.className = 'copy-button';
                    copyButton.textContent = 'Copy SQL';
                    copyButton.onclick = () => {
                        navigator.clipboard.writeText(dataObj.sql).then(() => {
                            copyButton.textContent = 'Copied!';
                            copyButton.classList.add('copied');
                            setTimeout(() => {
                                copyButton.textContent = 'Copy SQL';
                                copyButton.classList.remove('copied');
                            }, 2000);
                        });
                    };
                    
                    pre.appendChild(copyButton);
                    pre.appendChild(code);
                    sqlContent.appendChild(pre);
                    
                    // Create table from data
                    const table = document.createElement('table');
                    table.className = 'data-table';
                    
                    // Add number formatting function
                    const formatNumber = (value) => {
                        if (value === null || value === undefined || value === '') {
                            return value;
                        }
                        const num = Number(value);
                        if (isNaN(num)) {
                            return value;
                        }
                        return `$${num.toLocaleString('en-US', {
                            minimumFractionDigits: 0,
                            maximumFractionDigits: 0
                        })}`;
                    };
                    
                    // Add headers
                    const headers = Object.keys(dataObj.data);
                    const thead = document.createElement('thead');
                    const headerRow = document.createElement('tr');
                    headers.forEach(header => {
                        const th = document.createElement('th');
                        th.textContent = header;
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);
                    table.appendChild(thead);
                    
                    // Create set of metric names for easy lookup
                    const metricSet = new Set(dataObj.metrics?.map(m => m.toUpperCase()) || []);
                    
                    // Add data rows
                    const tbody = document.createElement('tbody');
                    const rowCount = dataObj.data[headers[0]].length;
                    for (let i = 0; i < rowCount; i++) {
                        const row = document.createElement('tr');
                        headers.forEach(header => {
                            const td = document.createElement('td');
                            const value = dataObj.data[header][i];
                            
                            // Format if this is a metric column
                            if (metricSet.has(header)) {
                                td.textContent = formatNumber(value);
                                td.style.textAlign = 'right';
                            } else {
                                td.textContent = value;
                            }
                            
                            row.appendChild(td);
                        });
                        tbody.appendChild(row);
                    }
                    table.appendChild(tbody);
                    dataContent.appendChild(table);
                    
                    messageDiv.appendChild(tabsContainer);
                    messageDiv.appendChild(chartContent);
                    messageDiv.appendChild(dataContent);
                    messageDiv.appendChild(sqlContent);
                    
                    // Add tab switching functionality
                    chartTab.addEventListener('click', () => {
                        chartTab.classList.add('active');
                        dataTab.classList.remove('active');
                        sqlTab.classList.remove('active');
                        chartContent.classList.add('active');
                        dataContent.classList.remove('active');
                        sqlContent.classList.remove('active');
                    });

                    dataTab.addEventListener('click', () => {
                        dataTab.classList.add('active');
                        chartTab.classList.remove('active');
                        sqlTab.classList.remove('active');
                        dataContent.classList.add('active');
                        chartContent.classList.remove('active');
                        sqlContent.classList.remove('active');
                    });
                    
                    sqlTab.addEventListener('click', () => {
                        sqlTab.classList.add('active');
                        dataTab.classList.remove('active');
                        chartTab.classList.remove('active');
                        sqlContent.classList.add('active');
                        dataContent.classList.remove('active');
                        chartContent.classList.remove('active');
                    });
                } else {
                    // Regular message - render as markdown
                    messageDiv.innerHTML = marked.parse(text);
                }
            } catch (e) {
                // Not JSON, render as markdown
                messageDiv.innerHTML = marked.parse(text);
            }
            
            messagesContainer.appendChild(messageDiv);
            
            // Ensure content is fully scrolled and new message is visible
            setTimeout(() => {
                // First scroll the message into view
                messageDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                
                // Then scroll the container to the bottom
                setTimeout(() => {
                    messagesContainer.scrollTo({
                        top: messagesContainer.scrollHeight,
                        behavior: 'smooth'
                    });
                }, 100);
            }, 100);
            
            // Apply syntax highlighting to code blocks
            messageDiv.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightBlock(block);
            });
        }

        let audioRecorder = null;
        let audioPlayer = null;

        // Function to get microphone input and send it to WebSocket
        async function startAudio() {
            try {
                // Initialize WebSocket
                connectWebSocket();
                console.log('WebSocket connecting...');

                // Initialize audio player
                audioPlayer = new Player();
                await audioPlayer.init(24000);

                ws.onopen = () => {
                    console.log('WebSocket connection established');
                };

                // Handle WebSocket messages
                ws.onmessage = event => {
                    console.log('Raw WebSocket message:', event.data);
                    try {
                        const message = JSON.parse(event.data);
                        console.log('Parsed WebSocket message:', message);
                        
                        switch (message.type) {
                            case "assistant.response":
                                // Handle assistant's text response
                                addMessage(message.text, false);
                                document.getElementById('loadingIndicator').classList.remove('active');
                                break;
                                
                            case "user.input":
                                // Handle user's transcribed input
                                addMessage(message.text, true);
                                // Show loading indicator after user input is received
                                document.getElementById('loadingIndicator').classList.add('active');
                                break;
                                
                            case "function_call":
                                // Keep loading indicator active during function calls
                                document.getElementById('loadingIndicator').classList.add('active');
                                break;
                                
                            case "error":
                                // Handle error messages
                                console.error('Error from server:', message.error);
                                // Only show error message if it's not from a normal disconnect
                                if (message.error && !message.error.includes('WebSocketDisconnect')) {
                                    addMessage(`Error: ${message.error}`, false);
                                }
                                document.getElementById('loadingIndicator').classList.remove('active');
                                break;

                            case "function_call_output":
                                // Handle function call outputs
                                try {
                                    const result = JSON.parse(message.output);
                                    console.log('Function call output:', result);
                                    if (result.type === "query_result") {
                                        // It's a query result, display it
                                        addMessage(JSON.stringify({
                                            sql: result.sql,
                                            data: result.data,
                                            chart_config: result.chart_config
                                        }), false);
                                        document.getElementById('loadingIndicator').classList.remove('active');
                                    } else if (result.type === "assistant.response") {
                                        // It's a direct text response from the assistant
                                        addMessage(result.text, false);
                                        document.getElementById('loadingIndicator').classList.remove('active');
                                    } else if (result.metrics || result.dimensions) {
                                        // It's metadata about available metrics/dimensions
                                        // Let the model's next message handle the display
                                        console.log('Received metadata:', result);
                                    } else {
                                        // Other function outputs, display as text
                                        addMessage(message.output, false);
                                        document.getElementById('loadingIndicator').classList.remove('active');
                                    }
                                } catch (e) {
                                    // If not JSON or other error, display as text
                                    addMessage(message.output, false);
                                    document.getElementById('loadingIndicator').classList.remove('active');
                                }
                                break;
                                
                            default:
                                console.log('Unhandled message type:', message.type);
                        }
                    } catch (error) {
                        console.error('Error parsing WebSocket message:', error, event.data);
                    }
                };

                ws.onclose = (event) => {
                    console.log('WebSocket closed:', event.code, event.reason);
                    if (event.code !== 1000) {
                        // Only show error for unexpected closures
                        console.error('WebSocket closed unexpectedly');
                        alert('Connection lost. Please try again.');
                    }
                    isRecording = false;
                    toggleButton.classList.remove('recording');
                    toggleButton.innerHTML = `
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                            <line x1="12" y1="19" x2="12" y2="23"/>
                            <line x1="8" y1="23" x2="16" y2="23"/>
                        </svg>
                        Start Recording
                    `;
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    // Only show alert for actual errors, not normal disconnects
                    if (!isRecording) {
                        alert('Connection error. Please try again.');
                    }
                };

                let buffer = new Uint8Array();

                const appendToBuffer = (newData) => {
                    const newBuffer = new Uint8Array(buffer.length + newData.length);
                    newBuffer.set(buffer);
                    newBuffer.set(newData, buffer.length);
                    buffer = newBuffer;
                };

                const handleAudioData = (data) => {
                    // Only process data if WebSocket is open
                    if (!ws || ws.readyState !== WebSocket.OPEN) {
                        return;  // Skip sending if WebSocket is not open
                    }

                    const uint8Array = new Uint8Array(data);
                    appendToBuffer(uint8Array);

                    if (buffer.length >= BUFFER_SIZE) {
                        const toSend = buffer.slice(0, BUFFER_SIZE);
                        buffer = buffer.slice(BUFFER_SIZE);

                        const regularArray = String.fromCharCode(...toSend);
                        const base64 = btoa(regularArray);

                        ws.send(JSON.stringify({
                            type: 'input_audio_buffer.append',
                            audio: base64
                        }));
                    }
                };

                // Initialize recorder
                audioRecorder = new Recorder(handleAudioData);
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        channelCount: 1,
                        sampleRate: 24000
                    }
                });

                await audioRecorder.start(stream);

                // Wait for WebSocket connection to be established
                if (ws.readyState !== WebSocket.OPEN) {
                    await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('WebSocket connection timeout'));
                        }, 5000);  // 5 second timeout
                        
                        ws.addEventListener('open', () => {
                            clearTimeout(timeout);
                            resolve();
                        });
                        ws.addEventListener('error', (error) => {
                            clearTimeout(timeout);
                            reject(error);
                        });
                    });
                }

                // Send initial session update
                ws.send(JSON.stringify({
                    type: "session.update",
                    session: {
                        input_audio_transcription: {
                            model: "whisper-1"
                        }
                    }
                }));

            } catch (error) {
                console.error('Error starting audio:', error);
                alert('Error starting audio. Please check your settings and try again.');
                await stopAudio(); // Ensure cleanup happens if we fail to start
            }
        }

        async function stopAudio() {
            try {
                if (audioRecorder) {
                    await audioRecorder.stop();
                    audioRecorder = null;
                }
                
                if (audioPlayer) {
                    audioPlayer.stop();
                    audioPlayer = null;
                }

                if (ws && ws.readyState === WebSocket.OPEN) {
                    // Send a graceful shutdown message
                    ws.send(JSON.stringify({
                        type: 'session.close',
                        reason: 'User stopped recording'
                    }));
                    
                    // Wait for any pending messages to be processed
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    ws.close(1000, 'User stopped recording');
                }
            } catch (error) {
                console.error('Error stopping audio:', error);
            } finally {
                ws = null;
            }
        }

        // Button to toggle audio
        const toggleButton = document.getElementById('toggleAudio');
        let isRecording = false;

        toggleButton.addEventListener('click', async () => {
            if (!isRecording) {
                await startAudio();
                toggleButton.classList.add('recording');
                toggleButton.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <rect x="6" y="6" width="12" height="12" rx="2"/>
                    </svg>
                    Stop Recording
                `;
                isRecording = true;
            } else {
                await stopAudio();
                toggleButton.classList.remove('recording');
                toggleButton.innerHTML = `
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                        <line x1="12" y1="19" x2="12" y2="23"/>
                        <line x1="8" y1="23" x2="16" y2="23"/>
                    </svg>
                    Start Recording
                `;
                isRecording = false;
            }
        });
    </script>
</body>
</html>